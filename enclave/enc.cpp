// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

// Include the trusted helloworld header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
// TODO refactor to h
#include "structs.cpp"

bool verify_gpu_certificate_chain(STACK_OF(X509) *gpu_certificate_chain, HopperSettings &settings, AttestationReport &attestation_report) {
    constexpr size_t SIZE_OF_FWID_IN_BYTES = 48;
    const char *TCG_DICE_FWID_OID = "2.23.133.5.4.1";
    const ASN1_OBJECT *oid = OBJ_txt2obj(TCG_DICE_FWID_OID, 1);
    char oid_str[256];
    OBJ_obj2txt(oid_str, 256, oid, 1);
    W_DEBUG("Begin OpaqueField\n")
    OpaqueField fwid_field = attestation_report.response_message.opaque_data.get_field("OPAQUE_FIELD_ID_FWID");
    W_DEBUG("End OpaqueField\n")
    if (fwid_field.field_size != 0) {
        const unsigned char *attestation_fwid = fwid_field.field_data;
        X509 *cert_one = sk_X509_value(gpu_certificate_chain, 0);
        int ext_index = X509_get_ext_by_OBJ(cert_one, oid, -1);
        if (ext_index == -1) {
            W_ERROR("The certificate does not contain the FWID extension.\n");
            return false;
        }
        X509_EXTENSION *fwid_ext = X509_get_ext(cert_one, ext_index);
        ASN1_OCTET_STRING *fwid_ext_data = X509_EXTENSION_get_data(fwid_ext);
        char cert_fwid[SIZE_OF_FWID_IN_BYTES];
        memcpy(cert_fwid, fwid_ext_data->data + fwid_ext_data->length - SIZE_OF_FWID_IN_BYTES, SIZE_OF_FWID_IN_BYTES);
        // TODO attestation report fwid length??
        if (memcmp(attestation_fwid, cert_fwid, SIZE_OF_FWID_IN_BYTES)) {
            W_ERROR("The reported FWID does not match the certificate.\n");
            return false;
        }
    }

    W_DEBUG("Begin verify_certificate_chain\n")
    return verify_certificate_chain(gpu_certificate_chain, settings, HopperSettings::CERT_CHAIN_VERIFICATION_MODE::GPU_ATTESTATION);

}

bool ocsp_certificate_chain_validation(STACK_OF(X509) *certificate_chain, const HopperSettings &settings, int mode) {
    // TODO
    return true;
}

char *parse_vbios_version(const unsigned char *vbios_version, int vbios_version_length) {
    char *value = to_hex(vbios_version, vbios_version_length, true);
    int value_len = vbios_version_length * 2;

    int first_half = value_len / 2;
    int second_half = value_len - value_len / 2;

    // Don't ask
    char *tmp = (char *) malloc(second_half + 2);
    memcpy(tmp, value + first_half, second_half);
    memcpy(tmp + second_half, value + first_half - 2, 2);
    free(value);

    char *result = (char *) malloc((second_half + 1) / 2 + second_half + 1);
    int i, idx = 0;
    for (i = 0; i < second_half; i += 2, idx += 3) {
        result[idx] = tmp[i];
        result[idx + 1] = tmp[i + 1];
        result[idx + 2] = '.';
    }
    result[idx] = tmp[i];
    result[idx + 1] = tmp[i + 1];
    result[idx + 2] = '\0';
    free(tmp);
    return result;
}

bool verify_attestation_report(AttestationReport &attestation_report, X509 *gpu_leaf_certificate, const unsigned char *nonce, const char *driver_version, const char *vbios_version, HopperSettings &settings) {
    unsigned char *report_nonce = attestation_report.response_message.Nonce;
    // printf("%i %i %i : %i %i %i\n", nonce[0], nonce[1], nonce[2], report_nonce[0], report_nonce[1], report_nonce[2]);
    if (memcmp(nonce, report_nonce, settings.SIZE_OF_NONCE_IN_BYTES)) {
        W_ERROR("The nonce in the attestation report does not match the nonce sent to the GPU.\n");
        // return false;
    }
    settings.nonce_comparison = true;

    // Check driver version
    OpaqueField driver_version_from_attestation_report = attestation_report.response_message.opaque_data.get_field("OPAQUE_FIELD_ID_DRIVER_VERSION");
    if (memcmp(driver_version, driver_version_from_attestation_report.field_data, driver_version_from_attestation_report.field_size)) {
        W_ERROR("The driver version in the attestation report does not match the driver version of the GPU.\n");
        char print_driver[11];
        memcpy(print_driver, driver_version_from_attestation_report.field_data, driver_version_from_attestation_report.field_size);
        print_driver[driver_version_from_attestation_report.field_size] = '\0';
        W_ERROR("%s vs %s\n", print_driver, driver_version);
        // return false;
    }
    settings.attestation_report_driver_version_match = true;

    // Check vbios version
    OpaqueField vbios_version_from_attestation_report = attestation_report.response_message.opaque_data.get_field("OPAQUE_FIELD_ID_VBIOS_VERSION");
    char *vbios_version_str = parse_vbios_version(vbios_version_from_attestation_report.field_data, vbios_version_from_attestation_report.field_size);
    if (strcmp(vbios_version, vbios_version_str)) {
        W_ERROR("The VBIOS version in the attestation report does not match the VBIOS version of the GPU.\n");
        return false;
    }
    // TODO free errors
    free(vbios_version_str);
    settings.attestation_report_vbios_version_match = true;

    // Verify signature
    bool signature_verification_status = attestation_report.verify_signature(gpu_leaf_certificate, settings.signature_length);
    if (!signature_verification_status) {
        W_ERROR("Failed to verify the signature of the attestation report.\n");
        return false;
    }

    return true;
}

bool attest(AttestationReport &attestation_report, STACK_OF(X509) *certificate_chain, const unsigned char *nonce, const char *driver_version, const char *vbios_version, HopperSettings &settings) {
    W_DEBUG("Begin verify_gpu_certificate_chain\n");
    bool cert_verification_status = verify_gpu_certificate_chain(certificate_chain, settings, attestation_report);
    if (!cert_verification_status) {
        W_ERROR("Failed to verify the GPU certificate chain.\n");
        return false;
    }
    W_DEBUG("Done verify_gpu_certificate_chain\n");
    settings.gpu_cert_chain_verification = true;

    // TODO OCSP response passed in
    bool cert_chain_revocation_status = ocsp_certificate_chain_validation(certificate_chain, settings, HopperSettings::CERT_CHAIN_VERIFICATION_MODE::GPU_ATTESTATION);
    if (!cert_chain_revocation_status) {
        W_ERROR("Failed to validate the GPU certificate chain revocation using OCSP.\n");
        return false;
    }
    settings.gpu_cert_check_complete = true;

    // TODO nonce, driver version, vbios version - should these be passed into the function and provided by the guest?
    bool attestation_report_status = verify_attestation_report(attestation_report, sk_X509_value(certificate_chain, 0), nonce, driver_version, vbios_version, settings);
    if (!attestation_report_status) {
        W_ERROR("Failed to verify the attestation report.\n");
        return false;
    }

    // RIM validation
    RIM driver_rim = RIM(RIM_NAME::DRIVER, settings);
    bool driver_rim_verified = driver_rim.verify(driver_version, RIM_NAME::DRIVER, settings);
    if (driver_rim_verified) {
        settings.driver_rim_signature_verification = true;
    } else {
        W_ERROR("Failed to verify the driver RIM.\n");
    }

    // VBIOS RIM
    // OpaqueField project = attestation_report.response_message.opaque_data.get_field("OPAQUE_FIELD_ID_PROJECT");
    // OpaqueField project_sku = attestation_report.response_message.opaque_data.get_field("OPAQUE_FIELD_ID_PROJECT_SKU");
    // OpaqueField chip_sku = attestation_report.response_message.opaque_data.get_field("OPAQUE_FIELD_ID_CHIP_SKU");
    OpaqueField vbios_version_field = attestation_report.response_message.opaque_data.get_field("OPAQUE_FIELD_ID_VBIOS_VERSION");

    // TODO process vbios id for rim file
    // const char *vbios_version_for_id = vbios_version_field.field_data;
    RIM vbios_rim = RIM(RIM_NAME::VBIOS, settings);
    char *vbios_version_str = parse_vbios_version(vbios_version_field.field_data, vbios_version_field.field_size);
    bool vbios_rim_verified = vbios_rim.verify(vbios_version_str, RIM_NAME::VBIOS, settings);
    free(vbios_version_str);
    if (vbios_rim_verified) {
        settings.vbios_rim_signature_verification = true;
    } else {
        W_ERROR("Failed to verify the VBIOS RIM.\n");
    }

    Verifier verifier =  Verifier(attestation_report, driver_rim, vbios_rim, settings);
    bool verification_status = verifier.verify(settings);

    return verification_status;
}

#include <limits.h>

bool gpu_attestation() {
    W_DEBUG("Starting GPU attestation.\n");

    size_t data_length;
    unsigned char *attestation_data = read_file("certs/attestation_report.bin", &data_length);

    W_DEBUG("Attestation report read.\n");
    
    // printf("%i\n", (unsigned int) *attestation_data);
    HopperSettings settings;
    AttestationReport attestation_report(attestation_data, data_length, settings);

    W_DEBUG("Attestation report parsed.\n");

    if (!attestation_report.valid) {
        return false;
    }
    STACK_OF(X509) *gpu_certificate_chain = sk_X509_new_null();
    if (!gpu_certificate_chain) {
        W_ERROR("Failed to create the certificate stack.\n");
        return false;
    }

    size_t cert_length;
    unsigned char *ucert_data = read_file("certs/cert_chain.pem", &cert_length);
    char *cert_data = convert_unsigned_char_star(ucert_data, cert_length);
    free(ucert_data);
    BIO *cert_bio = BIO_new_mem_buf(cert_data, cert_length);
    if (!cert_bio) {
        W_ERROR("Failed to open the certificate file.\n");
        return false;
    }

    size_t num_certs;
    X509 *cert = PEM_read_bio_X509(cert_bio, NULL, NULL, NULL);
    // X509_print_fp(stdout, cert);
    for (num_certs = 0; cert && num_certs < settings.MAX_CERT_CHAIN_LENGTH; num_certs++) {
        sk_X509_push(gpu_certificate_chain, cert);
        cert = PEM_read_bio_X509(cert_bio, NULL, NULL, NULL);
        // if (cert)
            // X509_print_fp(stdout, cert);
    }
    // printf("\n\n\n");
    BIO_free(cert_bio);
    if (num_certs > settings.MAX_CERT_CHAIN_LENGTH) {
        W_ERROR("The number of certificates in the chain exceeds the maximum limit.\n");
        return false;
    }

    W_DEBUG("Certificate chain parsed.\n")

    // TODO nonce
    unsigned char nonce[32] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32};
    bool attested = attest(attestation_report, gpu_certificate_chain, nonce, "550.54.15", "96.00.74.00.11", settings);
    settings.print_status();

    free(attestation_data);
    sk_X509_pop_free(gpu_certificate_chain, X509_free);
    return true;
}

// int main() {
//     gpu_attestation();
// }

// This is the function that the host calls. It prints
// a message in the enclave before calling back out to
// the host to print a message from there too.
void enclave_helloworld()
{
    // Print a message from the enclave. Note that this
    // does not directly call fprintf, but calls into the
    // host and calls fprintf from there. This is because
    // the fprintf function is not part of the enclave
    // as it requires support from the kernel.
    fprintf(stdout, "Hello world from the enclave\n");

    // Call back into the host
    // oe_result_t result = host_helloworld();
    // if (result != OE_OK)
    // {
    //     fprintf(
    //         stderr,
    //         "Call to host_helloworld failed: result=%u (%s)\n",
    //         result,
    //         oe_result_str(result));
    // }
    gpu_attestation();
}
